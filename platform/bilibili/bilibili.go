package bilibili

import (
	"errors"
	"fmt"

	"github.com/luxcgo/lifesaver/platform"
	"github.com/luxcgo/lifesaver/util"
)

func init() {
	platform.SharedManager.RegisterCtrl(
		new(bilibiliCtrl),
	)
}

type bilibiliCtrl struct {
	platform.Base
}

func (c *bilibiliCtrl) Type() string {
	return "bilibili"
}

func (c *bilibiliCtrl) Name() string {
	return "哔哩哔哩"
}

func (c *bilibiliCtrl) WithRoomOn() platform.Option {
	type roomInit struct {
		Code int64 `json:"code"`
		Data struct {
			RoomID     int64 `json:"room_id"`
			LiveStatus int64 `json:"live_status"`
		}
	}

	return func(s *platform.Snapshot) error {
		roomInit := new(roomInit)
		req := &util.HttpRequest{
			// https://github.com/SocialSisterYi/bilibili-API-collect/blob/master/live/info.md#获取房间页初始化信息
			URL:    "https://api.live.bilibili.com/room/v1/Room/room_init",
			Method: "POST",
			RequestData: map[string]string{
				"id": s.RoomID,
			},
			ResponseData: roomInit,
			ContentType:  "application/form-data",
		}
		if err := req.Send(); err != nil {
			return err
		}
		if roomInit.Code == 0 || roomInit.Data.LiveStatus == 1 {
			s.RoomID = fmt.Sprint(roomInit.Data.RoomID)
			s.RoomOn = true
			return nil
		}
		return errors.New("not on air")
	}
}

func (c *bilibiliCtrl) WithStreamURL() platform.Option {
	return c.getRealURL
}

func (c *bilibiliCtrl) getAutoGenerated(roomID string, currentQn int) (*AutoGenerated, error) {
	auto := new(AutoGenerated)
	req := &util.HttpRequest{
		// https://github.com/SocialSisterYi/bilibili-API-collect/blob/master/live/live_stream.md
		URL:    "https://api.live.bilibili.com/xlive/web-room/v2/index/getRoomPlayInfo",
		Method: "GET",
		RequestData: map[string]string{
			"room_id":  roomID,
			"protocol": "0,1",
			"format":   "0,1,2",
			"codec":    "0,1",
			"qn":       fmt.Sprint(currentQn),
			"platform": "h5",
			"ptype":    "8",
		},
		ResponseData: auto,
		ContentType:  "application/form-data",
	}
	err := req.Send()
	return auto, err
}

func (c *bilibiliCtrl) getRealURL(s *platform.Snapshot) error {
	// 原画画质
	const highestQn = 10000
	auto, err := c.getAutoGenerated(s.RoomID, highestQn)
	if err != nil {
		return err
	}
	for _, stream := range auto.Data.PlayurlInfo.Playurl.Stream {
		if stream.ProtocolName != "http_hls" {
			continue
		}
		for _, format := range stream.Format {
			if format.FormatName != "ts" {
				continue
			}
			var qnMax int
			if len(format.Codec) <= 0 {
				continue
			}
			for _, qn := range format.Codec[0].AcceptQn {
				if qn > qnMax {
					qnMax = qn
				}
			}
			if format.Codec[0].CurrentQn != qnMax && qnMax > 0 {
				auto, err = c.getAutoGenerated(s.RoomID, qnMax)
				if err != nil {
					return err
				}
			}
		}
	}

	for _, stream := range auto.Data.PlayurlInfo.Playurl.Stream {
		if stream.ProtocolName != "http_hls" {
			continue
		}
		for _, format := range stream.Format {
			if format.FormatName != "ts" {
				continue
			}
			if len(format.Codec) <= 0 {
				continue
			}
			baseURL := format.Codec[0].BaseURL
			urlInfo := format.Codec[0].URLInfo[0]
			streamURL := urlInfo.Host + baseURL + urlInfo.Extra
			s.StreamURL = streamURL
			return nil
		}
	}
	return fmt.Errorf("fail to getRealURL")
}

// https://mholt.github.io/json-to-go/
type AutoGenerated struct {
	Code    int    `json:"code"`
	Message string `json:"message"`
	TTL     int    `json:"ttl"`
	Data    struct {
		RoomID          int           `json:"room_id"`
		ShortID         int           `json:"short_id"`
		UID             int           `json:"uid"`
		IsHidden        bool          `json:"is_hidden"`
		IsLocked        bool          `json:"is_locked"`
		IsPortrait      bool          `json:"is_portrait"`
		LiveStatus      int           `json:"live_status"`
		HiddenTill      int           `json:"hidden_till"`
		LockTill        int           `json:"lock_till"`
		Encrypted       bool          `json:"encrypted"`
		PwdVerified     bool          `json:"pwd_verified"`
		LiveTime        int           `json:"live_time"`
		RoomShield      int           `json:"room_shield"`
		AllSpecialTypes []interface{} `json:"all_special_types"`
		PlayurlInfo     struct {
			ConfJSON string `json:"conf_json"`
			Playurl  struct {
				Cid     int `json:"cid"`
				GQnDesc []struct {
					Qn      int    `json:"qn"`
					Desc    string `json:"desc"`
					HdrDesc string `json:"hdr_desc"`
				} `json:"g_qn_desc"`
				Stream []struct {
					ProtocolName string `json:"protocol_name"`
					Format       []struct {
						FormatName string `json:"format_name"`
						Codec      []struct {
							CodecName string `json:"codec_name"`
							CurrentQn int    `json:"current_qn"`
							AcceptQn  []int  `json:"accept_qn"`
							BaseURL   string `json:"base_url"`
							URLInfo   []struct {
								Host      string `json:"host"`
								Extra     string `json:"extra"`
								StreamTTL int    `json:"stream_ttl"`
							} `json:"url_info"`
							HdrQn     interface{} `json:"hdr_qn"`
							DolbyType int         `json:"dolby_type"`
						} `json:"codec"`
					} `json:"format"`
				} `json:"stream"`
				P2PData struct {
					P2P      bool        `json:"p2p"`
					P2PType  int         `json:"p2p_type"`
					MP2P     bool        `json:"m_p2p"`
					MServers interface{} `json:"m_servers"`
				} `json:"p2p_data"`
				DolbyQn interface{} `json:"dolby_qn"`
			} `json:"playurl"`
		} `json:"playurl_info"`
	} `json:"data"`
}
